%{
	#include <net/sock.h>
	#include <linux/fdtable.h> 
%}

global sock_ptr = 0;

probe syscall.mq_notify
{
	if(execname() == "test")
	{
		printf("\n\n(%d-%d) [SYSCALL] ==>> mq_notify (%s)\n", pid(), tid(), argstr)
	}
}

probe syscall.mq_notify.return
{
	if(execname() == "test")
	{
		if(sock_ptr != 0)
		{
			dump_netlink_sock(sock_ptr);
			sock_ptr = 0;
		}
		printf("(%d-%d) [SYSCALL] <<== mq_notify = %x\n\n\n", pid(), tid(), $return)
	}
}

probe kernel.function ("fdget")
{
	if(execname() == "test")
	{
		printf("(%d-%d) [vfs] ==>> fdget (%s)\n", pid(), tid(), $$parms)
	}
}

probe kernel.function ("fdput")
{
	if(execname() == "test")
	{
		printf("(%d-%d) [vfs] ==>> fdput (%s)\n", pid(), tid(), $$parms)
	}
}

probe kernel.function ("copy_from_user")
{
	if(execname() == "test")
	{
		printf("(%d-%d) [uland] ==> copy_from_user ()\n", pid(), tid())
	}
}

probe kernel.function ("alloc_skb")
{
	if(execname() == "test")
	{
		printf("(%d-%d) [skb] ==> alloc_skb (%s)\n", pid(), tid(), $$parms)
	}
}

probe kernel.function ("skb_put")
{
	if(execname() == "test")
	{
		printf("(%d-%d) [skb] ==> skb_put (%s)\n", pid(), tid(), $$parms)
	}
}
probe kernel.function ("skb_put").return
{
	if(execname() == "test")
	{
		printf("(%d-%d) [skb] <== skb_put = %x\n", pid(), tid(), $return)
	}
}

probe kernel.function ("netlink_getsockbyfilp")
{
	if(execname() == "test")
	{
		printf("(%d-%d) [netlink] ==> netlink_getsockbyfilp (%s)\n", pid(), tid(), $$parms)
	}
}
probe kernel.function ("netlink_getsockbyfilp").return
{
	if(execname() == "test")
	{
		printf("(%d-%d) [netlink] <== netlink_getsockbyfilp = %x\n", pid(), tid(), $return)
		sock_ptr = $return;
	}
}

function dump_netlink_sock:long (arg_sock:long)
%{
	struct netlink_ring {
			void                    **pg_vec;
			unsigned int            head;
			unsigned int            frames_per_block;
			unsigned int            frame_size;
			unsigned int            frame_max;

			unsigned int            pg_vec_order;
			unsigned int            pg_vec_pages;
			unsigned int            pg_vec_len;

			atomic_t                pending;
	};

	struct netlink_sock {
			/* struct sock has to be the first member of netlink_sock */
			struct sock             sk;
			u32                     portid;
			u32                     dst_portid;
			u32                     dst_group;
			u32                     flags;
			u32                     subscriptions;
			u32                     ngroups;
			unsigned long           *groups;
			unsigned long           state;
			size_t                  max_recvmsg_len;
			wait_queue_head_t       wait;
			bool                    cb_running;
			struct netlink_callback cb;
			struct mutex            *cb_mutex;
			struct mutex            cb_def_mutex;
			void                    (*netlink_rcv)(struct sk_buff *skb);
			int                     (*netlink_bind)(int group);
			void                    (*netlink_unbind)(int group);
			struct module           *module;
	#ifdef CONFIG_NETLINK_MMAP
			struct mutex            pg_vec_lock;
			struct netlink_ring     rx_ring;
			struct netlink_ring     tx_ring;
			atomic_t                mapped;
	#endif /* CONFIG_NETLINK_MMAP */
	};

	struct sock *sk = (void*) STAP_ARG_arg_sock;
	struct netlink_sock *nlk = (void*) sk;

	_stp_printf("-={ dump_netlink_sock: %p }=-\n", nlk);
	_stp_printf("- sk = %p\n", sk);
	_stp_printf("- sk->sk_rmem_alloc = %d\n", sk->sk_rmem_alloc);
	_stp_printf("- sk->sk_rcvbuf = %d\n", sk->sk_rcvbuf);
	_stp_printf("- sk->sk_refcnt = %d\n", sk->sk_refcnt);
	
	// need for bypass 
	_stp_printf("- (before) nlk->state = %x\n", (nlk->state & 0x1));
	nlk->state |= 1;
	_stp_printf("- (after) nlk->state = %x\n", (nlk->state & 0x1));

	// // need for bypass
	// _stp_printf("- sk->sk_flags = %x\n", sk->sk_flags);
	// _stp_printf("- SOCK_DEAD = %x\n", SOCK_DEAD);
	// sk->sk_flags |= (1 << SOCK_DEAD);
	// _stp_printf("- sk->sk_flags = %x\n", sk->sk_flags);

	_stp_printf("-={ dump_netlink_sock: END}=-\n");
%}

function remove_fd3_from_fdt:long (arg_unused:long)
%{
	struct files_struct *files = current->files;
	struct fdtable *fdt = files_fdtable(files);
	_stp_printf("!!>>> REMOVING FD=3 FROM FDT <<<!!\n");
	fdt->fd[3] = NULL;
%}

probe kernel.function ("netlink_attachskb")
{
	if(execname() == "test")
	{
		printf("(%d-%d) [netlink] ==> netlink_attachskb (%s)\n", pid(), tid(), $$parms)
		dump_netlink_sock($sk);
	}
}
probe kernel.function ("netlink_attachskb").return
{
	if(execname() == "test")
	{
		printf("(%d-%d) [netlink] <== netlink_attachskb = %x\n", pid(), tid(), $return)
		remove_fd3_from_fdt(0);
	}
}

probe kernel.function ("netlink_detachskb")
{
	if(execname() == "test")
	{
		printf("(%d-%d) [netlink] ==> netlink_detachskb (%s)\n", pid(), tid(), $$parms)
	}
}
probe kernel.function ("netlink_detachskb").return
{
	if(execname() == "test")
	{
		printf("(%d-%d) [netlink] <== netlink_detachskb\n", pid(), tid())
	}
}
