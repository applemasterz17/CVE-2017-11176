SYSCALL_DEFINE2(mq_notify, mqd_t, mqdes, const struct sigevent __user *, u_notification)
{
    int ret;
    struct fd f;
    struct sock *sock;
    struct inode *inode;
    struct sigevent notification;
    struct mqueue_inode_info *info;
    struct sk_buff *nc;

    // userland 에서 넘어온 sigevent 인자가 null 인지 체크하고, kernel로 복사
    if (u_notification)
    {
        if (copy_from_user(&notification, u_notification, sizeof(struct sigevent)))
        {
            return -EFAULT;
        }
    }

    // mq_notify() SYSCALL 을 "Linux Audit" 에 등록한다
    audit_mq_notify(mqdes, u_notification ? &notification : NULL);

    nc = NULL;
    sock = NULL;

    if (u_notification != NULL)
    {
        if (unlikely(notification.sigev_notify != SIGEV_NONE &&
                     notification.sigev_notify != SIGEV_SIGNAL &&
                     notification.sigev_notify != SIGEV_THREAD))
        {
            return -EINVAL;
        }

        if (notification.sigev_notify == SIGEV_SIGNAL && !valid_signal(notification.sigev_signo))
        {
            return -EINVAL;
        }

        // [통과] sigevent.sigev_notify 는 SIGEV_THREAD 로 세팅해야함
        if (notification.sigev_notify == SIGEV_THREAD)
        {
            long timeo;

            // notify_skb(notify_cookie: nc) 를 할당한다
            nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL)
            {
                ret = -ENOMEM;
                goto out;
            }

            // [통과] sigev.sigev_value.sival_ptr 은 유효한 userland 버퍼 주소로 세팅
            if (copy_from_user(nc->data, notification.sigev_value.sival_ptr, NOTIFY_COOKIE_LEN))
            {
                ret = -EFAULT;
                goto out;
            }

            skb_put(nc, NOTIFY_COOKIE_LEN);

            // file 과 sock 객체 카운터 둘다 1인 상태
        retry:
            // [통과] sigev_signo 에 AF_NETLINK 타입 socket fd 를 전달해야함
            // [통과] 두번째 retry 시도에서 fd 를 close 해서 실패 해야함
            // file 객체 카운터 증가
            f = fdget(notification.sigev_signo);
            if (!f.file)
            {
                ret = -EBADF;
                goto out;
            }

            // file 에서 sock 객체를 찾은뒤 저장(포인터), sock 객체 카운터 증가
            sock = netlink_getsockbyfilp(f.file);

            // file 객체 카운터 감소
            fdput(f);

            // 유효하지 않은 sock 포인터면 sock 을 NULL 로 세팅하고 out 으로 진입
            if (IS_ERR(sock))
            {
                ret = PTR_ERR(sock);
                sock = NULL;
                goto out;
            }

            timeo = MAX_SCHEDULE_TIMEOUT;

            // sock 객체의 receive 큐에 sk_buff(=nc) 를 enqueue, sock 객체 카운터 감소
            ret = netlink_attachskb(sock, nc, &timeo, NULL);
            if (ret == 1)
            {
                // [통과] ret 이 1이 되게 해야함
                goto retry;
            }
            if (ret)
            {
                sock = NULL;
                nc = NULL;
                goto out;
            }
        }
    }

    f = fdget(mqdes);
    if (!f.file)
    {
        ret = -EBADF;
        goto out;
    }

    inode = file_inode(f.file);
    if (unlikely(f.file->f_op != &mqueue_file_operations))
    {
        ret = -EBADF;
        goto out_fput;
    }
    info = MQUEUE_I(inode);

    ret = 0;
    spin_lock(&info->lock);
    if (u_notification == NULL)
    {
        if (info->notify_owner == task_tgid(current))
        {
            remove_notification(info);
            inode->i_atime = inode->i_ctime = CURRENT_TIME;
        }
    }
    else if (info->notify_owner != NULL)
    {
        ret = -EBUSY;
    }
    else
    {
        switch (notification.sigev_notify)
        {
        case SIGEV_NONE:
            info->notify.sigev_notify = SIGEV_NONE;
            break;
        case SIGEV_THREAD:
            info->notify_sock = sock;
            info->notify_cookie = nc;
            sock = NULL;
            nc = NULL;
            info->notify.sigev_notify = SIGEV_THREAD;
            break;
        case SIGEV_SIGNAL:
            info->notify.sigev_signo = notification.sigev_signo;
            info->notify.sigev_value = notification.sigev_value;
            info->notify.sigev_notify = SIGEV_SIGNAL;
            break;
        }

        info->notify_owner = get_pid(task_tgid(current));
        info->notify_user_ns = get_user_ns(current_user_ns());
        inode->i_atime = inode->i_ctime = CURRENT_TIME;
    }
    spin_unlock(&info->lock);
out_fput:
    fdput(f);
out:
    if (sock)
        // sock 객체 카운터 감소 !!
        netlink_detachskb(sock, nc);
    else if (nc)
        dev_kfree_skb(nc);

    return ret;
}