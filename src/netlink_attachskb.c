int netlink_attachskb(struct sock *sk, struct sk_buff *skb, long *timeo, struct sock *ssk)
{
    struct netlink_sock *nlk;

    nlk = nlk_sk(sk);

    // sk_rcvbuf : 최대 사이즈 || sk_rmem_alloc : 현재 사이즈
    // [통과] 내부로 들어가야함, sk_rmem_alloc 을 증가시킨다
    // unicast -> attachskb -> set_owner_r -> 증가!
    if ((atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf ||
         test_bit(NETLINK_CONGESTED, &nlk->state)) &&
        !netlink_skb_is_mmaped(skb))
    {
        DECLARE_WAITQUEUE(wait, current);
        if (!*timeo)
        {
            if (!ssk || netlink_is_kernel(ssk))
                netlink_overrun(sk);
            sock_put(sk);
            kfree_skb(skb);
            return -EAGAIN;
        }

        __set_current_state(TASK_INTERRUPTIBLE);
        add_wait_queue(&nlk->wait, &wait);

        if ((atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf ||
             test_bit(NETLINK_CONGESTED, &nlk->state)) &&
            !sock_flag(sk, SOCK_DEAD))
        {
            // 이 시점에서 프로세스 block 됨
            *timeo = schedule_timeout(*timeo);
        } // [통과] 프로세스 깨우기 (_setsockopt() -> wakeup...)

        __set_current_state(TASK_RUNNING);
        remove_wait_queue(&nlk->wait, &wait);

        // sock 객체 카운터 감소
        sock_put(sk);

        if (signal_pending(current))
        {
            kfree_skb(skb);
            return sock_intr_errno(*timeo);
        }

        // 천국: enqueue 를 실패하고 return 1 : 재시도
        return 1;
    }

    // 지옥: enqueue 를 성공하고 return 0
    netlink_skb_set_owner_r(skb, sk);
    return 0;
}