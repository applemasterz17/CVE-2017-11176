/*
    - skb_set_owner_r
    - netlink_attachskb
    - netlink_unicast   
    - netlink_sendmsg   // there is a lots of "other" callers of netlink_unicast
    - sock->ops->sendmsg()          
    - __sock_sendmsg_nosec()
    - __sock_sendmsg()
    - sock_sendmsg()
    - __sys_sendmsg()
    - SYSCALL_DEFINE3(sendmsg, ...)
*/

static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
                           struct msghdr *msg, size_t len)
{
    struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
    struct sock *sk = sock->sk;
    struct netlink_sock *nlk = nlk_sk(sk);
    // addr 은 user-controlled value
    DECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);
    u32 dst_portid;
    u32 dst_group;
    struct sk_buff *skb;
    int err;
    struct scm_cookie scm;
    u32 netlink_skb_flags = 0;

    // [통과] msg->msg_flags 는 MSG_OOB 가 아니어야함
    if (msg->msg_flags & MSG_OOB)
        return -EOPNOTSUPP;

    // __sock_sendmsg_nosec() 에서 siocb->scm 을 NULL 로 세팅해서 내부 진입함
    if (NULL == siocb->scm)
        siocb->scm = &scm;

    // [통과] msg->msg_controllen 은 0 보다 작거나 같아야함
    err = scm_send(sock, msg, siocb->scm, true);
    if (err < 0)
    {
        return err;
    }

    // [진입] msg->msg_namelen 은 0 이 아니어야함
    if (msg->msg_namelen)
    {
        err = -EINVAL;
        // [통과] addr->nl_family 는 AF_NETLINK 로 세팅
        if (addr->nl_family != AF_NETLINK)
        {
            goto out;
        }
        // addr 조작으로 portid, group 원하는값 설정 가능
        dst_portid = addr->nl_pid;        // [통과] addr->nl_pid 는 "도착지" 소켓 nl_pid
        dst_group = ffs(addr->nl_groups); // [통과] addr->nl_groups 를 0 으로 설정해 unicast
        err = -EPERM;
        if ((dst_group || dst_portid) &&
            !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND)) // sender: NETLINK_USERSOCK
            goto out;
        netlink_skb_flags |= NETLINK_SKB_DST;
    }
    else // 이미 연결됨
    {
        dst_portid = nlk->dst_portid;
        dst_group = nlk->dst_group;
    }

    /*
    static inline int netlink_allowed(const struct socket *sock, unsigned int flag)
    {
        // [통과] "sender" 소켓은 NETLINK_USERSOCK 
        return (nl_table[sock->sk->sk_protocol].flags & flag) ||
                ns_capable(sock_net(sock->sk)->user_ns, CAP_NET_ADMIN);
    }
    */

    // 소켓을 만드는 중이니 첫 호출때는 pid 가 설정이 안됨
    // autobind 덕분에 두번째 호출에는 pid 가 설정되어있음
    // 알아서 넘어감
    if (!nlk->portid)
    {
        err = netlink_autobind(sock);
        if (err)
            goto out;
    }

    if (netlink_tx_is_mmaped(sk) &&
        msg->msg_iov->iov_base == NULL)
    {
        err = netlink_mmap_sendmsg(sk, msg, dst_portid, dst_group,
                                   siocb);
        goto out;
    }

    err = -EMSGSIZE;
    // len = 모든 iovec len 의 합
    // [통과] msg->iovlen 은 1 로 세팅 , 한개의 iovec 사용
    // [통과] msg->msg_iov->iov_len 은 sk->sk_sndbuf-32 보다 작거나 같아야함
    // [통과] msg->msg_iov->iov_base 는 userland readable 주소
    // [통과] msg->msg_iov 또한 userland readable 주소
    if (len > sk->sk_sndbuf - 32)
        goto out;
    err = -ENOBUFS;
    skb = netlink_alloc_large_skb(len, dst_group);
    if (skb == NULL)
        goto out;

    // 넘어감
    NETLINK_CB(skb).portid = nlk->portid;
    NETLINK_CB(skb).dst_group = dst_group;
    NETLINK_CB(skb).creds = siocb->scm->creds;
    NETLINK_CB(skb).flags = netlink_skb_flags;

    err = -EFAULT;
    // msg->msg_iov 유효한 주소, 이미 위에서 체크함
    if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len))
    {
        kfree_skb(skb);
        goto out;
    }

    // LSM 체크, 통과 못하면 망함, 기도해야함
    err = security_netlink_send(sk, skb);
    if (err)
    {
        kfree_skb(skb);
        goto out;
    }

    // 위에서 unicast 를 위해 이미 0으로 설정, 통과함
    if (dst_group)
    {
        atomic_inc(&skb->users);
        netlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);
    }

    // !! 목표  !!
    /*
    sk is our sender netlink_sock
    skb is a socket buffer filled with msg->msg_iov->iov_base data of size msg->msg_iov->iov_len
    dst_pid is a controlled pid (msg->msg_name->nl_pid) pointing to our receiver netlink socket
    msg->msg_flasg&MSG_DONTWAIT indicates if netlink_unicast() should block or not
    */
    err = netlink_unicast(sk, skb, dst_portid, msg->msg_flags & MSG_DONTWAIT);

out:
    scm_destroy(siocb->scm);
    return err;
}
