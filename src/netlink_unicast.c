/*
    sk: receiver's netlink_sock
    dst_pid: receiver 소켓 

    ssk: sender 소켓 
    skb: 소켓 버퍼 
    
*/
int netlink_unicast(struct sock *ssk, struct sk_buff *skb, u32 portid, int nonblock)
{
    struct sock *sk;
    int err;
    long timeo;

    // 무시 해도 됨
    skb = netlink_trim(skb, gfp_any());

    // msg->msg_flags 를 MSG_DONTWAIT 으로 세팅
    timeo = sock_sndtimeo(ssk, nonblock);
retry:
    // receiver 의 reference counter 증가
    sk = netlink_getsockbyportid(ssk, portid);
    if (IS_ERR(sk))
    {
        kfree_skb(skb);
        return PTR_ERR(sk);
    }

    // receiver 소켓이 kernel 소켓인지 검사한다
    // NETLINK_GENERIC 은 kernel 소켓이므로
    // receiver 소켓을 NETLINK_USERSOCK 타입으로 생성 해줘야한다
    if (netlink_is_kernel(sk))
        return netlink_unicast_kernel(sk, skb, ssk);

    // BPF 필터 설정부분
    if (sk_filter(sk, skb))
    {
        err = skb->len;
        kfree_skb(skb);
        sock_put(sk);
        return err;
    }

    // 버퍼에 공간이 있으면 owner 경로로 가서 공간을 채움
    // 버퍼에 공간이 없으면 블락 없이 -EAGAIN 리턴, 리턴값으로 버퍼가 꽉 찾는지 알수있음
    err = netlink_attachskb(sk, skb, &timeo, ssk);
    if (err == 1)
        goto retry;
    if (err)
        return err;

    // receiver 버퍼 리스트에 추가 (실제 도착지에 저장되는 순간)
    // receiver 의 reference counter 증가
    return netlink_sendskb(sk, skb);
}
EXPORT_SYMBOL(netlink_unicast);